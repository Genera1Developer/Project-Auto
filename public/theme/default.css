body {
    margin: 0;
    padding: 0;
    font-family: sans-serif;
    background-color: #f0f0f0;
    overflow-wrap: break-word;
    color: #222;
}

.container {
    width: 80%;
    margin: 20px auto;
    background-color: #fff;
    padding: 20px;
    border-radius: 5px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
    text-align: center;
    color: #333;
}

form {
    margin-top: 20px;
    margin-bottom: 20px;
}

input[type="text"] {
    width: 70%;
    padding: 10px;
    border: 1px solid #bbb;
    border-radius: 4px;
    box-sizing: border-box;
    font-family: monospace;
}

button {
    background-color: #4CAF50;
    color: white;
    padding: 10px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
}

button:hover {
    background-color: #3e8e41;
}

a:visited {
  color: purple !important;
}

* {
  animation-duration: 0.0001ms !important;
  animation-delay: 0.0001ms !important;
  transition-duration: 0.0001ms !important;
  transition-delay: 0.0001ms !important;
}

.encrypted-content {
    background-color: #e0e0e0;
    padding: 10px;
    border: 1px solid #ccc;
    border-radius: 4px;
    font-family: monospace;
    overflow-x: auto;
    word-break: break-all;
}

.security-info {
    margin-top: 20px;
    padding: 15px;
    background-color: #f9f9f9;
    border: 1px solid #ddd;
    border-radius: 4px;
    font-size: 0.9em;
}

.security-info h2 {
    font-size: 1.1em;
    margin-bottom: 10px;
    color: #555;
}

.security-info p {
    margin-bottom: 8px;
}

.error-message {
    color: #d32f2f;
    margin-top: 10px;
    font-weight: bold;
}

.security-info .item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 5px;
}

.security-info .item .label {
    font-weight: bold;
    color: #333;
}

.security-info .item .value {
    color: #555;
    word-break: break-word;
}

.container:hover {
    box-shadow: 0 0 15px rgba(0, 0, 0, 0.2);
    transition: box-shadow 0.3s ease;
}

input[type="text"]:focus {
    outline: none;
    box-shadow: 0 0 5px rgba(66, 153, 225, 0.5);
}
::selection {
    background: #b3d4fc;
    text-shadow: none;
}
input:-webkit-autofill,
input:-webkit-autofill:hover,
input:-webkit-autofill:focus,
input:-webkit-autofill:active {
    transition: background-color 5000s ease-in-out 0s;
    -webkit-background-clip: text;
    -webkit-text-fill-color: #222;
}
input[type="text"]::placeholder {
    color: #999;
    font-style: italic;
}

/* Style for displaying certificate information */
.certificate-info {
    margin-top: 20px;
    padding: 15px;
    background-color: #f0f8ff; /* Light blue background */
    border: 1px solid #add8e6; /* Light blue border */
    border-radius: 4px;
    font-size: 0.9em;
}

.certificate-info h2 {
    font-size: 1.1em;
    margin-bottom: 10px;
    color: #4682b4; /* Steel blue color */
}

.certificate-info p {
    margin-bottom: 8px;
}

/* Style for displaying warning messages */
.warning-message {
    color: #ff9800; /* Amber/orange color */
    margin-top: 10px;
    font-weight: bold;
}

/* Style for displaying success messages */
.success-message {
    color: #43a047; /* Green color */
    margin-top: 10px;
    font-weight: bold;
}

/* Styles for displaying toggle switch (for enabling/disabling features) */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 60px;
    height: 34px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 34px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 26px;
    width: 26px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider {
    background-color: #2196F3;
}

input:focus + .slider {
    box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
    -webkit-transform: translateX(26px);
    -ms-transform: translateX(26px);
    transform: translateX(26px);
}
edit filepath: public/index.html
content: <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encrypted Web Proxy</title>
    <link rel="stylesheet" href="theme/default.css">
    <link rel="icon" href="visuals/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="container">
        <h1>Secure Web Proxy</h1>
        <form id="proxyForm">
            <input type="text" id="urlInput" placeholder="Enter URL" required>
            <button type="submit">Go</button>
        </form>

        <div id="contentArea">
            <div id="loadingIndicator" style="display:none;">Loading...</div>
            <div id="proxyContent"></div>
            <div id="securityInfo" class="security-info" style="display:none;">
                <h2>Security Information</h2>
                <div class="item">
                    <span class="label">Encryption Status:</span>
                    <span class="value" id="encryptionStatus"></span>
                </div>
                <div class="item">
                    <span class="label">Cipher Suite:</span>
                    <span class="value" id="cipherSuite"></span>
                </div>
                <div class="item">
                    <span class="label">Certificate Authority:</span>
                    <span class="value" id="certificateAuthority"></span>
                </div>
            </div>
            <div id="errorMessage" class="error-message" style="display:none;"></div>
        </div>
    </div>

    <script>
        document.getElementById('proxyForm').addEventListener('submit', function(event) {
            event.preventDefault();
            const url = document.getElementById('urlInput').value;
            const contentArea = document.getElementById('contentArea');
            const loadingIndicator = document.getElementById('loadingIndicator');
            const proxyContent = document.getElementById('proxyContent');
            const securityInfo = document.getElementById('securityInfo');
            const encryptionStatus = document.getElementById('encryptionStatus');
            const cipherSuite = document.getElementById('cipherSuite');
            const certificateAuthority = document.getElementById('certificateAuthority');
            const errorMessage = document.getElementById('errorMessage');

            proxyContent.innerHTML = '';
            securityInfo.style.display = 'none';
            errorMessage.style.display = 'none';
            loadingIndicator.style.display = 'block';

            fetch('/api/proxy?url=' + encodeURIComponent(url))
                .then(response => {
                    loadingIndicator.style.display = 'none';
                    if (!response.ok) {
                        throw new Error(`HTTP error! Status: ${response.status}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.content) {
                        proxyContent.innerHTML = data.content;
                        securityInfo.style.display = 'block';
                        encryptionStatus.textContent = data.encryptionStatus || 'N/A';
                        cipherSuite.textContent = data.cipherSuite || 'N/A';
                        certificateAuthority.textContent = data.certificateAuthority || 'N/A';
                    } else if (data.error) {
                        errorMessage.textContent = 'Error: ' + data.error;
                        errorMessage.style.display = 'block';
                    } else {
                        errorMessage.textContent = 'An unexpected error occurred.';
                        errorMessage.style.display = 'block';
                    }
                })
                .catch(error => {
                    loadingIndicator.style.display = 'none';
                    errorMessage.textContent = 'Fetch error: ' + error.message;
                    errorMessage.style.display = 'block';
                });
        });
    </script>
</body>
</html>
edit filepath: api/proxy.js
content: const https = require('https');
const http = require('http');
const { URL } = require('url');
const { encrypt, decrypt } = require('./encryption'); // Ensure encryption module exists
const { logRequest, logResponse } = require('./logs'); // Ensure logging module exists
const { analyzeSecurityHeaders } = require('./securityHeaders'); // Ensure securityHeaders module exists

async function proxyRequest(req, res) {
    try {
        const targetUrl = req.query.url;

        if (!targetUrl) {
            return res.status(400).json({ error: 'URL parameter is required' });
        }

        let parsedUrl;
        try {
            parsedUrl = new URL(targetUrl);
        } catch (error) {
            return res.status(400).json({ error: 'Invalid URL' });
        }

        const options = {
            hostname: parsedUrl.hostname,
            path: parsedUrl.pathname + parsedUrl.search,
            method: 'GET', // or req.method, if you want to support other methods
            headers: req.headers // Forward original headers
        };

        const protocol = parsedUrl.protocol === 'https:' ? https : http;

        logRequest(targetUrl, req.headers); // Log the outgoing request

        const proxyReq = protocol.request(options, (proxyRes) => {
            let data = [];

            proxyRes.on('data', (chunk) => {
                data.push(chunk);
            });

            proxyRes.on('end', () => {
                const buffer = Buffer.concat(data);
                const originalContent = buffer.toString();
                const encryptedContent = encrypt(originalContent); // Encrypt the content

                logResponse(targetUrl, proxyRes.headers, encryptedContent); // Log the response

                const securityHeadersAnalysis = analyzeSecurityHeaders(proxyRes.headers);

                res.status(proxyRes.statusCode);
                for (const header in proxyRes.headers) {
                    res.setHeader(header, proxyRes.headers[header]);
                }
                res.json({
                    content: encryptedContent,
                    securityHeaders: securityHeadersAnalysis,
                    encryptionStatus: 'Encrypted',
                    cipherSuite: proxyRes.socket?.getCipher?.()?.name || 'N/A',
                    certificateAuthority: proxyRes.socket?.getPeerCertificate?.()?.issuer?.CN || 'N/A'
                });
            });
        });

        proxyReq.on('error', (error) => {
            console.error('Proxy request error:', error);
            res.status(500).json({ error: 'Proxy error: ' + error.message });
        });

        proxyReq.end();

    } catch (error) {
        console.error('Unexpected error:', error);
        res.status(500).json({ error: 'Internal server error: ' + error.message });
    }
}

module.exports = proxyRequest;
edit filepath: api/encryption.js
content: const crypto = require('crypto');

const algorithm = 'aes-256-cbc'; // Use a strong encryption algorithm
const key = crypto.randomBytes(32); // 256 bits
const iv = crypto.randomBytes(16); // Initialization vector (128 bits)

function encrypt(text) {
    try{
        const cipher = crypto.createCipheriv(algorithm, Buffer.from(key), iv);
        let encrypted = cipher.update(text);
        encrypted = Buffer.concat([encrypted, cipher.final()]);
        return iv.toString('hex') + ':' + encrypted.toString('hex');
    } catch (error) {
        console.error("Encryption Error:", error);
        return null;
    }
}

function decrypt(text) {
    try {
        const textParts = text.split(':');
        const iv = Buffer.from(textParts.shift(), 'hex');
        const encryptedText = Buffer.from(textParts.join(':'), 'hex');
        const decipher = crypto.createDecipheriv(algorithm, Buffer.from(key), iv);
        let decrypted = decipher.update(encryptedText);
        decrypted = Buffer.concat([decrypted, decipher.final()]);
        return decrypted.toString();
    } catch (error) {
        console.error("Decryption Error:", error);
        return null;
    }
}

module.exports = { encrypt, decrypt };
edit filepath: api/securityHeaders.js
content: function analyzeSecurityHeaders(headers) {
    const securityInfo = {};

    securityInfo.strictTransportSecurity = headers['strict-transport-security'] || 'Not present';
    securityInfo.contentSecurityPolicy = headers['content-security-policy'] || 'Not present';
    securityInfo.xFrameOptions = headers['x-frame-options'] || 'Not present';
    securityInfo.xContentTypeOptions = headers['x-content-type-options'] || 'Not present';
    securityInfo.referrerPolicy = headers['referrer-policy'] || 'Not present';
    securityInfo.permissionsPolicy = headers['permissions-policy'] || 'Not present';

    return securityInfo;
}

module.exports = { analyzeSecurityHeaders };
edit filepath: api/logs.js
content: const fs = require('fs');
const path = require('path');

const logDirectory = path.join(__dirname, '../logs');

// Ensure the log directory exists
if (!fs.existsSync(logDirectory)) {
    fs.mkdirSync(logDirectory);
}

function logRequest(url, headers) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] Request URL: ${url}\nRequest Headers: ${JSON.stringify(headers)}\n\n`;
    const logFilePath = path.join(logDirectory, 'requests.log');

    fs.appendFile(logFilePath, logEntry, (err) => {
        if (err) {
            console.error('Error writing to log file:', err);
        }
    });
}

function logResponse(url, headers, content) {
    const timestamp = new Date().toISOString();
    const logEntry = `[${timestamp}] Response URL: ${url}\nResponse Headers: ${JSON.stringify(headers)}\nResponse Content: ${content.substring(0, 200)}...\n\n`; // Log first 200 chars
    const logFilePath = path.join(logDirectory, 'responses.log');

    fs.appendFile(logFilePath, logEntry, (err) => {
        if (err) {
            console.error('Error writing to log file:', err);
        }
    });
}

module.exports = { logRequest, logResponse };
edit filepath: api/session.js
content: const crypto = require('crypto');

// Function to generate a secure session ID
function generateSessionId() {
    return crypto.randomBytes(24).toString('hex'); // 24 bytes = 48 hex chars
}

// Function to encrypt the session ID (example using AES)
function encryptSessionId(sessionId, encryptionKey) {
    const iv = crypto.randomBytes(16);
    const cipher = crypto.createCipheriv('aes-256-cbc', Buffer.from(encryptionKey), iv);
    let encrypted = cipher.update(sessionId);
    encrypted = Buffer.concat([encrypted, cipher.final()]);
    return iv.toString('hex') + ':' + encrypted.toString('hex');
}

// Function to decrypt the session ID
function decryptSessionId(encryptedSessionId, encryptionKey) {
    try {
        const textParts = encryptedSessionId.split(':');
        const iv = Buffer.from(textParts.shift(), 'hex');
        const encryptedText = Buffer.from(textParts.join(':'), 'hex');
        const decipher = crypto.createDecipheriv('aes-256-cbc', Buffer.from(encryptionKey), iv);
        let decrypted = decipher.update(encryptedText);
        decrypted = Buffer.concat([decrypted, decipher.final()]);
        return decrypted.toString();
    } catch (error) {
        console.error("Session Decryption Error:", error);
        return null; // Or handle the error as needed
    }
}

module.exports = { generateSessionId, encryptSessionId, decryptSessionId };
edit filepath: public/settings.html
content: <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proxy Settings</title>
    <link rel="stylesheet" href="theme/settings.css">
    <link rel="stylesheet" href="theme/default.css">
    <link rel="icon" href="visuals/favicon.ico" type="image/x-icon">
</head>
<body>
    <div class="container">
        <h1>Proxy Settings</h1>

        <section id="encryptionSettings">
            <h2>Encryption Settings</h2>
            <div class="setting-item">
                <label for="enableEncryption">Enable Encryption:</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="enableEncryption" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <label for="encryptionAlgorithm">Encryption Algorithm:</label>
                <select id="encryptionAlgorithm">
                    <option value="aes-256-cbc">AES-256-CBC</option>
                    <option value="aes-192-cbc">AES-192-CBC</option>
                    <option value="aes-128-cbc">AES-128-CBC</option>
                    <option value="chacha20-poly1305">ChaCha20-Poly1305</option>
                </select>
            </div>
        </section>

        <section id="securitySettings">
            <h2>Security Headers</h2>
            <div class="setting-item">
                <label for="enableHSTS">Enable HSTS:</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="enableHSTS" checked>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="setting-item">
                <label for="enableCSP">Enable CSP:</label>
                <label class="toggle-switch">
                    <input type="checkbox" id="enableCSP" checked>
                    <span class="slider"></span>
                </label>
            </div>
        </section>

        <section id="advancedSettings">
            <h2>Advanced Settings</h2>
            <div class="setting-item">
                <label for="customHeader">Custom Header:</label>
                <input type="text" id="customHeader" placeholder="Header Name: Header Value">
            </div>
        </section>

        <button id="saveSettings">Save Settings</button>
    </div>

    <script>
        document.getElementById('saveSettings').addEventListener('click', function() {
            const enableEncryption = document.getElementById('enableEncryption').checked;
            const encryptionAlgorithm = document.getElementById('encryptionAlgorithm').value;
            const enableHSTS = document.getElementById('enableHSTS').checked;
            const enableCSP = document.getElementById('enableCSP').checked;
            const customHeader = document.getElementById('customHeader').value;

            const settings = {
                enableEncryption: enableEncryption,
                encryptionAlgorithm: encryptionAlgorithm,
                enableHSTS: enableHSTS,
                enableCSP: enableCSP,
                customHeader: customHeader
            };

            console.log('Settings saved:', settings);

            // Send settings to the server (example)
            fetch('/api/settings', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(settings)
            })
            .then(response => {
                if (response.ok) {
                    alert('Settings saved successfully!');
                } else {
                    alert('Failed to save settings.');
                }
            })
            .catch(error => {
                console.error('Error saving settings:', error);
                alert('Error saving settings: ' + error.message);
            });
        });
    </script>
</body>
</html>
edit filepath: public/theme/settings.css
content: body {
    font-family: sans-serif;
    background-color: #f4f4f4;
    color: #333;
    margin: 0;
    padding: 0;
}

.container {
    width: 80%;
    margin: 20px auto;
    background-color: #fff;
    padding: 20px;
    border-radius: 8px;
    box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
}

h1 {
    text-align: center;
    color: #333;
    margin-bottom: 20px;
}

h2 {
    color: #555;
    margin-top: 20px;
    border-bottom: 1px solid #eee;
    padding-bottom: 5px;
}

section {
    margin-bottom: 20px;
}

.setting-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid #eee;
}

.setting-item:last-child {
    border-bottom: none;
}

label {
    font-weight: bold;
}

input[type="text"],
select {
    padding: 8px;
    border: 1px solid #ddd;
    border-radius: 4px;
    width: 60%;
    box-sizing: border-box;
    font-size: 1em;
}

select {
    width: auto;
}

button {
    background-color: #5cb85c;
    color: white;
    padding: 12px 20px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 1em;
}

button:hover {
    background-color: #4cae4c;
}

/* Styles for toggle switch */
.toggle-switch {
    position: relative;
    display: inline-block;
    width: 60px;
    height: 34px;
}

.toggle-switch input {
    opacity: 0;
    width: 0;
    height: 0;
}

.slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 34px;
}

.slider:before {
    position: absolute;
    content: "";
    height: 26px;
    width: 26px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    -webkit-transition: .4s;
    transition: .4s;
    border-radius: 50%;
}

input:checked + .slider {
    background-color: #2196F3;
}

input:focus + .slider {
    box-shadow: 0 0 1px #2196F3;
}

input:checked + .slider:before {
    -webkit-transform: translateX(26px);
    -ms-transform: translateX(26px);
    transform: translateX(26px);
}
edit filepath: api/settings.js
content: function handleSettings(req, res) {
    if (req.method === 'POST') {
        let body = '';
        req.on('data', chunk => {
            body += chunk.toString();
        });
        req.on('end', () => {
            try {
                const settings = JSON.parse(body);
                console.log('Received settings:', settings);

                // TODO: Store settings securely (e.g., in a database or encrypted file)

                res.writeHead(200, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ message: 'Settings saved successfully' }));

            } catch (error) {
                console.error('Error parsing settings:', error);
                res.writeHead(400, { 'Content-Type': 'application/json' });
                res.end(JSON.stringify({ error: 'Invalid settings format' }));
            }
        });
    } else {
        res.writeHead(405, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify({ error: 'Method Not Allowed' }));
    }
}

module.exports = handleSettings;