<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encrypted Proxy</title>
    <link rel="stylesheet" href="style.css">
    <script src="particles.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Added styling to visually emphasize encryption theme */
        body {
            background-color: #1a1a1a;
            color: #eee;
            font-family: sans-serif;
        }
        .container {
            background-color: #222;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }
        h1 {
            color: #00bcd4; /* A cyan/blue shade */
        }
        .security-info {
            color: #4caf50; /* A green shade indicating security */
        }
        .input-group input {
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
        }
        .input-group button {
            background-color: #00bcd4;
            color: #fff;
            border: none;
        }
        .error {
            color: #f44336;
        }
        #loading {
            display: none;
            text-align: center;
            margin-top: 10px;
        }
        #proxyFrame {
            width: 100%;
            height: 600px; /* Adjust as needed */
            border: none;
            display: none; /* Initially hide the iframe */
        }

        /* Add a key icon to the URL input */
        .input-group {
            position: relative;
        }

        .input-group i.fa-key {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
        }

        .input-group input {
            padding-left: 30px; /* Adjust to accommodate the key icon */
        }

        /* Enhanced security message */
        .enhanced-security {
            background-color: #33691e; /* Darker green */
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
        }
        /* Added class for disabled button */
        .input-group button:disabled {
            background-color: #607d8b; /* Grey color */
            cursor: not-allowed;
        }
        /* Lock icon animation */
        .fa-lock {
            animation: rotateLock 2s linear infinite;
            display: inline-block;
        }

        @keyframes rotateLock {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        /* Added styling for key icon animation */
        .fa-key {
            animation: pulseKey 3s linear infinite;
        }

        @keyframes pulseKey {
            0% {
                transform: translateY(-50%) scale(1);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateY(-50%) scale(1);
                opacity: 0.8;
            }
        }
        /* Info message style */
        .info {
            color: #2196F3; /* A blue shade for informational messages */
            margin-top: 10px;
        }

    </style>
</head>
<body>
    <div id="particles-js"></div>

    <div class="container">
        <h1><i class="fas fa-lock"></i> Encrypted Web Proxy</h1>
        <p>Enter the URL to browse securely:</p>
        <div class="input-group">
            <i class="fas fa-key"></i>
            <input type="text" id="url" placeholder="https://example.com">
            <button id="browse"><i class="fas fa-arrow-right"></i> Browse</button>
        </div>
        <div id="error" class="error"></div>
        <div id="loading">Loading...</div>
        <div class="security-info">
            <i class="fas fa-shield-alt"></i> Your connection is encrypted. We use strong encryption to protect your data.
        </div>
        <div class="enhanced-security">
            <i class="fas fa-check-circle"></i> Enhanced Security Measures Active
        </div>
        <div id="info" class="info"></div>
        <iframe id="proxyFrame"></iframe>
    </div>

    <script nonce="${cspNonce}">
        document.addEventListener('DOMContentLoaded', () => {
            const urlInput = document.getElementById('url');
            const browseButton = document.getElementById('browse');
            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');
            const proxyFrame = document.getElementById('proxyFrame');
            const infoDiv = document.getElementById('info');
            const HASH_ITERATIONS = 100000; // Define constant for iterations
            const NONCE_LENGTH = 16; // Define constant for nonce length
            const KEY_CHECK_URL = '/api/checkKey'; //Endpoint to check key
            const AES_KEY_LENGTH = 256; // Define AES key length in bits
            const KEY_STORAGE_DURATION = 300000; // 5 minutes in milliseconds
            const LOAD_TIMEOUT = 30000; // 30 seconds
            const IV_LENGTH = 12; // Standard IV length for AES-GCM
            const SALT_LENGTH = 16; // Recommended salt length
            const PROXY_URL = '/api/proxy';
            const KEY_EXPIRY_CHECK_INTERVAL = 60000; // 60 seconds
            const ALLOWED_FRAME_ORIGIN = window.location.origin; // Ideally, this should be your server's origin.
            const REDIRECT_STATUS_CODES = [301, 302, 307, 308];
            const SERVICE_WORKER_URL = '/sw.js'; // Service worker URL
            const URL_PARAM_NAME = 'd'; // Name for the encrypted URL parameter
            const PREFETCH_SUBRESOURCES = true;

            // CSP Nonce for inline scripts (for stricter CSP)
            const cspNonce = generateNonce(16);

             // Function to generate a cryptographically secure nonce
            function generateNonce(length) {
                const randomBuffer = new Uint8Array(length);
                window.crypto.getRandomValues(randomBuffer);
                return Array.from(randomBuffer).map(b => b.toString(16).padStart(2, '0')).join('');
            }

              // Function to decrypt the URL using AES (for potential future use)
            async function decryptURL(ciphertext, key, iv) {
                try {
                    const encryptedData = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
                    const ivData = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
                    const alg = { name: 'AES-GCM', iv: ivData };
                    const jwk = await window.crypto.subtle.importKey('raw', new TextEncoder().encode(key), alg, false, ['decrypt']);
                    const decrypted = await window.crypto.subtle.decrypt(alg, jwk, encryptedData);
                    return new TextDecoder().decode(decrypted);
                } catch (error) {
                    console.error("Decryption failed:", error);
                    return null; // Or throw the error, depending on your needs
                }
            }

             // Function to hash the encryption key (SHA-256)
            async function hashKey(key) {
                const encodedKey = new TextEncoder().encode(key);
                const hashBuffer = await window.crypto.subtle.digest('SHA-256', encodedKey);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            }

            // Function to generate a cryptographically secure salt
            function generateSalt(length) {
              const randomBuffer = new Uint8Array(length);
              window.crypto.getRandomValues(randomBuffer);
              return Array.from(randomBuffer).map(b => b.toString(16).padStart(2, '0')).join('');
            }


            // Function to derive a key from the password and salt using PBKDF2
            async function deriveKey(password, salt) {
                const encodedPassword = new TextEncoder().encode(password);
                const encodedSalt = new TextEncoder().encode(salt);

                const algorithm = {
                    name: 'PBKDF2',
                    hash: 'SHA-256',
                    salt: encodedSalt,
                    iterations: HASH_ITERATIONS // Use the constant
                };

                const key = await window.crypto.subtle.importKey(
                    'raw',
                    encodedPassword,
                    algorithm,
                    false,
                    ['deriveKey']
                );

                const keyAlgorithm = { name: 'AES-GCM', length: 256 }; // Key length can be adjusted
                const derivedKey = await window.crypto.subtle.deriveKey(
                    algorithm,
                    key,
                    keyAlgorithm,
                    false,
                    ['encrypt', 'decrypt']
                );

                return derivedKey; // Return the CryptoKey object
            }

            // Function to encrypt the URL using AES-GCM
            async function encryptURL(url, key) {
                const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH));
                const encodedText = new TextEncoder().encode(url);
                const alg = { name: 'AES-GCM', iv: iv };

                const ciphertext = await window.crypto.subtle.encrypt(alg, key, encodedText);

                const encryptedData = btoa(String.fromCharCode(...new Uint8Array(ciphertext)));
                const ivData = btoa(String.fromCharCode(...iv));
                return { ciphertext: encryptedData, iv: ivData };
            }

             // Function to generate a random AES key.
            async function generateAESKey() {
                return await window.crypto.subtle.generateKey(
                    {
                        name: "AES-GCM",
                        length: AES_KEY_LENGTH,
                    },
                    true,
                    ["encrypt", "decrypt"]
                );
            }

            // Function to handle errors and display them to the user
            function handleErrors(error) {
                console.error(error);
                errorDiv.textContent = 'An unexpected error occurred. Please try again.';
            }

            // Function to check if the user is using HTTPS
            function isSecureContext() {
                return window.isSecureContext;
            }

            // Warn the user if they are not using HTTPS
            if (!isSecureContext()) {
                errorDiv.textContent = "Warning: You are not using a secure (HTTPS) connection. Encryption may not be fully effective.";
                errorDiv.style.color = '#ff9800'; // Amber color
            }

            // Function to perform a check for compromised keys
            async function checkKeyCompromise(keyHash) {
              try {
                const response = await fetch(KEY_CHECK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ keyHash: keyHash })
                });

                if (!response.ok) {
                    console.error('Key check request failed:', response.status);
                    return false; // Treat failure as not compromised, or handle differently
                }

                const data = await response.json();
                return data.isCompromised;
              } catch (error) {
                console.error('Error during key check:', error);
                return false; // Treat error as not compromised, or handle differently
              }
            }

             // Function to register service worker
            async function registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register(SERVICE_WORKER_URL);
                        console.log('Service worker registered:', registration);
                        infoDiv.textContent = 'Service worker registered for improved caching and offline support.';
                    } catch (error) {
                        console.error('Service worker registration failed:', error);
                        errorDiv.textContent = 'Failed to register service worker. The proxy might not work offline.';
                    }
                } else {
                    console.log('Service workers are not supported in this browser.');
                    infoDiv.textContent = 'Service workers are not supported in this browser.';
                }
            }

            // Call service worker registration on page load
            registerServiceWorker();

            browseButton.addEventListener('click', async () => {
                let url = urlInput.value.trim();

                if (!url) {
                    errorDiv.textContent = 'Please enter a URL.';
                    return;
                }

                try {
                  // Disable the browse button while processing
                  browseButton.disabled = true;
                  browseButton.classList.add('disabled');

                  // Normalize URL by adding https:// if no protocol specified
                  if (!url.startsWith('http://') && !url.startsWith('https://')) {
                      url = 'https://' + url;
                      urlInput.value = url; // Update the input field
                  }

                    // Improved URL validation
                    try {
                        new URL(url);
                    } catch (_) {
                        errorDiv.textContent = 'Please enter a valid URL.';
                        return;
                    }

                    // Generate a nonce for request tracking (example)
                    const nonce = generateNonce(NONCE_LENGTH);
                    console.log("Request Nonce:", nonce); // Log nonce for debugging

                    // Generate an AES Key
                    const aesKey = await generateAESKey();

                    // Encrypt the URL
                    const { ciphertext, iv } = await encryptURL(url, aesKey);

                    // Export the key to raw format to hash it
                    const rawKey = await window.crypto.subtle.exportKey("raw", aesKey);
                    const keyArray = Array.from(new Uint8Array(rawKey));
                    const keyHex = keyArray.map(b => b.toString(16).padStart(2, '0')).join('');


                    // Hash the derived key
                    const hashedKey = await hashKey(keyHex);
                    console.log("Hashed Key:", hashedKey); // Log the hashed key

                     // Check for compromised key *before* proceeding
                    const isCompromised = await checkKeyCompromise(hashedKey);
                    if (isCompromised) {
                        errorDiv.textContent = 'Potential security risk: Key compromise detected.';
                        return;
                    }

                    // Store IV in session storage
                    sessionStorage.setItem('aesIV', iv);

                    // Store key in session storage *before* passing parameters
                    sessionStorage.setItem('aesKey', keyHex);
                    sessionStorage.setItem('aesKeyTimestamp', Date.now().toString()); // Store timestamp

                    // Construct the URL with encrypted parameters.  Don't send IV in URL.
                    const formData = new FormData();
                    formData.append('ciphertext', ciphertext);
                    formData.append('nonce', nonce);
                    formData.append('keyHash', hashedKey);

                    // Show loading indicator
                    loadingDiv.style.display = 'block';
                    errorDiv.textContent = ''; // Clear any previous errors
                    proxyFrame.style.display = 'block';

                    // Add CSP to the iframe to prevent mixed content issues
                    proxyFrame.sandbox = 'allow-forms allow-scripts allow-same-origin allow-popups allow-downloads';
                    proxyFrame.setAttribute('csp', `default-src 'self'; script-src 'self' 'unsafe-inline' 'nonce-${cspNonce}'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self';`);

                    // Use POST request for better security and to avoid URL length limits
                    fetch(PROXY_URL, {
                        method: 'POST',
                        body: formData,
                        redirect: 'manual' // Prevent automatic redirects
                    })
                    .then(response => {
                        if (REDIRECT_STATUS_CODES.includes(response.status)) {
                            const redirectUrl = response.headers.get('Location');
                            console.log("Redirect detected:", redirectUrl);
                             // Encrypt and proxy the redirect URL
                             return encryptAndProxy(redirectUrl);
                        }
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(html => {
                        // Load the HTML content directly into the iframe
                        proxyFrame.contentWindow.document.open();
                        proxyFrame.contentWindow.document.write(html);
                        proxyFrame.contentWindow.document.close();

                        // Prefetch subresources
                        if (PREFETCH_SUBRESOURCES) {
                            prefetchSubresources(html);
                        }

                        // Post message to the iframe to notify about successful load
                        proxyFrame.contentWindow.postMessage({ type: 'proxyLoaded' }, ALLOWED_FRAME_ORIGIN);

                    })
                    .catch(error => {
                        console.error("Error loading proxy:", error);
                        errorDiv.textContent = 'Failed to load the page within the iframe.';
                    })
                    .finally(() => {
                        clearTimeout(timeoutId);
                        loadingDiv.style.display = 'none';
                    });

                     // Set a timeout to prevent indefinite loading
                    const timeoutId = setTimeout(() => {
                        if (loadingDiv.style.display === 'block') {
                            loadingDiv.style.display = 'none';
                            errorDiv.textContent = 'Request timed out. Please try again.';
                            proxyFrame.src = ''; // Clear the iframe to stop the request
                        }
                    }, LOAD_TIMEOUT); // Timeout after 30 seconds

                    // Function to clear sensitive information after delay
                    function clearSensitiveData() {
                        sessionStorage.removeItem('aesKey');
                        sessionStorage.removeItem('aesIV');
                        sessionStorage.removeItem('aesKeyTimestamp');
                    }

                     //Clear sensitive information from sessionStorage after a delay.
                    setTimeout(() => {
                        clearSensitiveData();
                    }, KEY_STORAGE_DURATION); //Clear after 5 minutes

                } catch (e) {
                    handleErrors(e); // Use the error handling function
                } finally {
                    // Re-enable the browse button
                    browseButton.disabled = false;
                    browseButton.classList.remove('disabled');
                    // Hide loading indicator (in case of immediate errors)
                    setTimeout(() => {
                        loadingDiv.style.display = 'none';
                    }, 500); // Small delay to ensure the loading indicator is shown briefly
                }
            });

            // Periodically check and clear key if expired
            setInterval(() => {
                const storedTimestamp = sessionStorage.getItem('aesKeyTimestamp');
                if (storedTimestamp) {
                    const timestamp = parseInt(storedTimestamp, 10);
                    if (Date.now() - timestamp > KEY_STORAGE_DURATION) {
                        // Key has expired, clear it
                        console.log("AES Key expired. Clearing from sessionStorage.");
                        sessionStorage.removeItem('aesKey');
                        sessionStorage.removeItem('aesIV');
                        sessionStorage.removeItem('aesKeyTimestamp');
                    }
                }
            }, KEY_EXPIRY_CHECK_INTERVAL);

             // Add event listener for iframe loaded message
            window.addEventListener('message', function(event) {
                if (event.origin === ALLOWED_FRAME_ORIGIN && event.data.type === 'proxyLoaded') {
                    console.log('Iframe proxy loaded successfully.');
                }
            });

             // Function to handle encryption and proxying of redirect URLs
            async function encryptAndProxy(redirectUrl) {
                try {
                  // Generate a nonce for request tracking (example)
                  const nonce = generateNonce(NONCE_LENGTH);
                  console.log("Redirect Nonce:", nonce); // Log nonce for debugging

                  // Generate an AES Key
                  const aesKey = await generateAESKey();

                  // Encrypt the URL
                  const { ciphertext, iv } = await encryptURL(redirectUrl, aesKey);

                  // Export the key to raw format to hash it
                  const rawKey = await window.crypto.subtle.exportKey("raw", aesKey);
                  const keyArray = Array.from(new Uint8Array(rawKey));
                  const keyHex = keyArray.map(b => b.toString(16).padStart(2, '0')).join('');

                  // Hash the derived key
                  const hashedKey = await hashKey(keyHex);
                  console.log("Hashed Key:", hashedKey); // Log the hashed key

                   // Check for compromised key *before* proceeding
                  const isCompromised = await checkKeyCompromise(hashedKey);
                  if (isCompromised) {
                      errorDiv.textContent = 'Potential security risk: Key compromise detected.';
                      return;
                  }

                  // Store IV in session storage
                  sessionStorage.setItem('aesIV', iv);

                  // Store key in session storage *before* passing parameters
                  sessionStorage.setItem('aesKey', keyHex);
                  sessionStorage.setItem('aesKeyTimestamp', Date.now().toString()); // Store timestamp

                  // Construct the URL with encrypted parameters.  Don't send IV in URL.
                  const formData = new FormData();
                  formData.append('ciphertext', ciphertext);
                  formData.append('nonce', nonce);
                  formData.append('keyHash', hashedKey);

                  // Show loading indicator
                  loadingDiv.style.display = 'block';
                  errorDiv.textContent = ''; // Clear any previous errors
                  proxyFrame.style.display = 'block';

                  // Add CSP to the iframe to prevent mixed content issues
                  proxyFrame.sandbox = 'allow-forms allow-scripts allow-same-origin allow-popups allow-downloads';
                  proxyFrame.setAttribute('csp', `default-src 'self'; script-src 'self' 'unsafe-inline' 'nonce-${cspNonce}'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self';`);

                  // Use POST request for better security and to avoid URL length limits
                  return fetch(PROXY_URL, {
                      method: 'POST',
                      body: formData,
                  })
                  .then(response => {
                      if (!response.ok) {
                          throw new Error(`HTTP error! status: ${response.status}`);
                      }
                      return response.text();
                  })
                  .then(html => {
                      // Load the HTML content directly into the iframe
                      proxyFrame.contentWindow.document.open();
                      proxyFrame.contentWindow.document.write(html);
                      proxyFrame.contentWindow.document.close();

                      // Prefetch subresources
                      if (PREFETCH_SUBRESOURCES) {
                          prefetchSubresources(html);
                      }

                      // Post message to the iframe to notify about successful load
                      proxyFrame.contentWindow.postMessage({ type: 'proxyLoaded' }, ALLOWED_FRAME_ORIGIN);
                  });
                } catch (error) {
                  console.error("Error handling redirect:", error);
                  errorDiv.textContent = 'Failed to load the redirect page.';
                } finally {
                    clearTimeout(timeoutId);
                    loadingDiv.style.display = 'none';
                }
            }

            // Function to prefetch subresources from the HTML
            function prefetchSubresources(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const subresourceTypes = ['link[rel="stylesheet"]', 'script[src]', 'img[src]'];

                subresourceTypes.forEach(selector => {
                    const elements = doc.querySelectorAll(selector);
                    elements.forEach(element => {
                        let url;
                        if (element.tagName === 'LINK') {
                            url = element.href;
                        } else if (element.tagName === 'SCRIPT' || element.tagName === 'IMG') {
                            url = element.src;
                        }

                        if (url) {
                            const prefetchLink = document.createElement('link');
                            prefetchLink.rel = 'prefetch';
                            prefetchLink.href = url;
                            document.head.appendChild(prefetchLink);
                            console.log('Prefetching:', url);
                        }
                    });
                });
            }
        });

        particlesJS.load('particles-js', 'particles-config.json', function() {
            console.log('callback - particles.js config loaded');
        });
    </script>
</body>
</html>