<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Encrypted Proxy</title>
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Added styling to visually emphasize encryption theme */
        body {
            background-color: #1a1a1a;
            color: #eee;
            font-family: sans-serif;
            margin: 0;
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #particles-js {
            position: fixed;
            width: 100%;
            height: 100%;
            top: 0;
            left: 0;
            z-index: 0;
        }

        .container {
            background-color: #222;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            width: 80%;
            max-width: 600px;
            z-index: 1;
        }
        h1 {
            color: #00bcd4;
            text-align: center;
        }
        .security-info {
            color: #4caf50;
            text-align: center;
            margin-top: 10px;
        }
        .input-group {
            position: relative;
            display: flex;
            align-items: center;
        }
        .input-group input {
            background-color: #333;
            color: #eee;
            border: 1px solid #555;
            padding: 10px 40px 10px 40px;
            border-radius: 5px;
            width: 100%;
            box-sizing: border-box;
        }
        .input-group button {
            background-color: #00bcd4;
            color: #fff;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            margin-left: 10px;
        }
        .error {
            color: #f44336;
            text-align: center;
            margin-top: 10px;
        }
        #loading {
            display: none;
            text-align: center;
            margin-top: 10px;
        }
        #proxyFrame {
            width: 100%;
            height: 600px;
            border: none;
            display: none;
            margin-top: 20px;
        }

        .input-group {
            position: relative;
            margin-bottom: 10px;
        }

        .input-group i.fa-key {
            position: absolute;
            left: 10px;
            top: 50%;
            transform: translateY(-50%);
            color: #777;
        }

        .input-group input {
            padding-left: 30px;
        }

        .enhanced-security {
            background-color: #33691e;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            text-align: center;
            font-weight: bold;
        }
        .input-group button:disabled {
            background-color: #607d8b;
            cursor: not-allowed;
        }
        .fa-lock {
            animation: rotateLock 2s linear infinite;
            display: inline-block;
        }

        @keyframes rotateLock {
            0% {
                transform: rotate(0deg);
            }
            100% {
                transform: rotate(360deg);
            }
        }
        .fa-key {
            animation: pulseKey 3s linear infinite;
        }

        @keyframes pulseKey {
            0% {
                transform: translateY(-50%) scale(1);
                opacity: 0.8;
            }
            50% {
                transform: translateY(-50%) scale(1.2);
                opacity: 1;
            }
            100% {
                transform: translateY(-50%) scale(1);
                opacity: 0.8;
            }
        }
        .info {
            color: #2196F3;
            margin-top: 10px;
            text-align: center;
        }
        .key-expired {
            color: #ffc107;
            font-weight: bold;
        }
        .container {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            transition: box-shadow 0.3s ease;
        }

        .container:hover {
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.5);
        }

        #proxyFrame {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        /* Styles for responsive design */
        @media (max-width: 768px) {
            .container {
                width: 95%; /* Take up more width on smaller screens */
                max-width: none; /* Remove max-width to fill available space */
                padding: 15px; /* Reduce padding for smaller screens */
            }

            .input-group {
                flex-direction: column; /* Stack input and button vertically */
            }

            .input-group input {
                width: 100%; /* Input takes full width */
                margin-bottom: 10px; /* Add spacing between input and button */
                padding: 10px 30px; /* Adjust padding to keep icon visible */
            }

            .input-group button {
                width: 100%; /* Button takes full width */
                margin-left: 0; /* Remove left margin */
            }

            h1 {
                font-size: 1.5em; /* Reduce heading size for smaller screens */
            }

            .security-info,
            .enhanced-security {
                font-size: 0.9em; /* Reduce font size for smaller screens */
            }

            #proxyFrame {
                height: 400px; /* Reduce iframe height for smaller screens */
            }
        }
    </style>
</head>
<body>
    <div id="particles-js"></div>

    <div class="container">
        <h1><i class="fas fa-lock"></i> Encrypted Web Proxy</h1>
        <p style="text-align: center;">Enter the URL to browse securely:</p>
        <div class="input-group">
            <i class="fas fa-key"></i>
            <input type="text" id="url" placeholder="https://example.com">
            <button id="browse"><i class="fas fa-arrow-right"></i> Browse</button>
        </div>
        <div id="error" class="error"></div>
        <div id="loading">Loading...</div>
        <div class="security-info">
            <i class="fas fa-shield-alt"></i> Your connection is encrypted. We use strong encryption to protect your data.
        </div>
        <div class="enhanced-security">
            <i class="fas fa-check-circle"></i> Enhanced Security Measures Active
        </div>
        <div id="info" class="info"></div>
        <div id="keyExpiryWarning" class="info key-expired" style="display:none;">
            <i class="fas fa-exclamation-triangle"></i> Encryption key will expire soon!
        </div>
        <iframe id="proxyFrame"></iframe>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const urlInput = document.getElementById('url');
            const browseButton = document.getElementById('browse');
            const errorDiv = document.getElementById('error');
            const loadingDiv = document.getElementById('loading');
            const proxyFrame = document.getElementById('proxyFrame');
            const infoDiv = document.getElementById('info');
            const keyExpiryWarningDiv = document.getElementById('keyExpiryWarning');
            const HASH_ITERATIONS = 100000;
            const NONCE_LENGTH = 16;
            const KEY_CHECK_URL = '/api/checkKey';
            const AES_KEY_LENGTH = 256;
            const KEY_STORAGE_DURATION = 300000;
            const LOAD_TIMEOUT = 30000;
            const IV_LENGTH = 12;
            const SALT_LENGTH = 16;
            const PROXY_URL = '/api/proxy';
            const KEY_EXPIRY_CHECK_INTERVAL = 60000;
            const ALLOWED_FRAME_ORIGIN = window.location.origin;
            const REDIRECT_STATUS_CODES = [301, 302, 307, 308];
            const SERVICE_WORKER_URL = '/sw.js';
            const URL_PARAM_NAME = 'd';
            const PREFETCH_SUBRESOURCES = true;
            const ENCRYPT_REDIRECTS = true;
            const ENABLE_KEY_ROTATION = true;
            const KEY_ROTATION_INTERVAL = 600000;
            const KEY_CHECK_INTERVAL = 1800000;
            let lastKeyCheckTime = 0;
            const PREVENT_AUTOFILL = true;
            const MAX_URL_LENGTH = 2048;
            const ENABLE_CSP = true;
            const SUBRESOURCE_INTEGRITY = true;
            const HSTS_MAX_AGE = 31536000;
            const HSTS_INCLUDE_SUBDOMAINS = true;
            const ENABLE_HSTS = true;
            const ENABLE_WEBGPU = false;

            function generateNonce(length) {
                const randomBuffer = new Uint8Array(length);
                window.crypto.getRandomValues(randomBuffer);
                return Array.from(randomBuffer).map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async function decryptURL(ciphertext, key, iv) {
                try {
                    const encryptedData = Uint8Array.from(atob(ciphertext), c => c.charCodeAt(0));
                    const ivData = Uint8Array.from(atob(iv), c => c.charCodeAt(0));
                    const alg = { name: 'AES-GCM', iv: ivData };
                    const jwk = await window.crypto.subtle.importKey('raw', new TextEncoder().encode(key), alg, false, ['decrypt']);
                    const decrypted = await window.crypto.subtle.decrypt(alg, jwk, encryptedData);
                    return new TextDecoder().decode(decrypted);
                } catch (error) {
                    console.error("Decryption failed:", error);
                    return null;
                }
            }

            async function hashKey(key) {
                const encodedKey = new TextEncoder().encode(key);
                const hashBuffer = await window.crypto.subtle.digest('SHA-256', encodedKey);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
                return hashHex;
            }

            function generateSalt(length) {
              const randomBuffer = new Uint8Array(length);
              window.crypto.getRandomValues(randomBuffer);
              return Array.from(randomBuffer).map(b => b.toString(16).padStart(2, '0')).join('');
            }

            async function deriveKey(password, salt) {
                const encodedPassword = new TextEncoder().encode(password);
                const encodedSalt = new TextEncoder().encode(salt);

                const algorithm = {
                    name: 'PBKDF2',
                    hash: 'SHA-256',
                    salt: encodedSalt,
                    iterations: HASH_ITERATIONS
                };

                const key = await window.crypto.subtle.importKey(
                    'raw',
                    encodedPassword,
                    algorithm,
                    false,
                    ['deriveKey']
                );

                const keyAlgorithm = { name: 'AES-GCM', length: 256 };
                const derivedKey = await window.crypto.subtle.deriveKey(
                    algorithm,
                    key,
                    keyAlgorithm,
                    false,
                    ['encrypt', 'decrypt']
                );

                return derivedKey;
            }

            async function encryptURL(url, key) {
                const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH));
                const encodedText = new TextEncoder().encode(url);
                const alg = { name: 'AES-GCM', iv: iv };

                const ciphertext = await window.crypto.subtle.encrypt(alg, key, encodedText);

                const encryptedData = btoa(String.fromCharCode(...new Uint8Array(ciphertext)));
                const ivData = btoa(String.fromCharCode(...iv));
                return { ciphertext: encryptedData, iv: ivData };
            }

            async function generateAESKey() {
                return await window.crypto.subtle.generateKey(
                    {
                        name: "AES-GCM",
                        length: AES_KEY_LENGTH,
                    },
                    true,
                    ["encrypt", "decrypt"]
                );
            }

            function handleErrors(error) {
                console.error(error);
                errorDiv.textContent = 'An unexpected error occurred. Please try again.';
            }

            function isSecureContext() {
                return window.isSecureContext;
            }

            if (!isSecureContext()) {
                errorDiv.textContent = "Warning: You are not using a secure (HTTPS) connection. Encryption may not be fully effective.";
                errorDiv.style.color = '#ff9800';
            }

            async function checkKeyCompromise(keyHash) {
              try {
                const response = await fetch(KEY_CHECK_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ keyHash: keyHash })
                });

                if (!response.ok) {
                    console.error('Key check request failed:', response.status);
                    return false;
                }

                const data = await response.json();
                return data.isCompromised;
              } catch (error) {
                console.error('Error during key check:', error);
                return false;
              }
            }

            async function registerServiceWorker() {
                if ('serviceWorker' in navigator) {
                    try {
                        const registration = await navigator.serviceWorker.register(SERVICE_WORKER_URL);
                        console.log('Service worker registered:', registration);
                        infoDiv.textContent = 'Service worker registered for improved caching and offline support.';
                    } catch (error) {
                        console.error('Service worker registration failed:', error);
                        errorDiv.textContent = 'Failed to register service worker. The proxy might not work offline.';
                    }
                } else {
                    console.log('Service workers are not supported in this browser.');
                    infoDiv.textContent = 'Service workers are not supported in this browser.';
                }
            }

            registerServiceWorker();

            async function rotateAESKey() {
              console.log('Rotating AES key...');
              const newAesKey = await generateAESKey();
              const rawKey = await window.crypto.subtle.exportKey("raw", newAesKey);
              const keyArray = Array.from(new Uint8Array(rawKey));
              const keyHex = keyArray.map(b => b.toString(16).padStart(2, '0')).join('');
              const hashedKey = await hashKey(keyHex);
              const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH));
              sessionStorage.setItem('aesIV', btoa(String.fromCharCode(...iv)));
              sessionStorage.setItem('aesKey', keyHex);
              sessionStorage.setItem('aesKeyTimestamp', Date.now().toString());
              sessionStorage.setItem('hashedKey', hashedKey);
              console.log('AES key rotated successfully.');
              displayKeyExpiryWarning();
            }

            if (ENABLE_KEY_ROTATION) {
                setInterval(rotateAESKey, KEY_ROTATION_INTERVAL);
            }

            async function periodicKeyCheck() {
                const currentTime = Date.now();
                if (currentTime - lastKeyCheckTime >= KEY_CHECK_INTERVAL) {
                    lastKeyCheckTime = currentTime;
                    const aesKeyHex = sessionStorage.getItem('aesKey');
                    if (aesKeyHex) {
                        const hashedKey = await hashKey(aesKeyHex);
                        const isCompromised = await checkKeyCompromise(hashedKey);
                        if (isCompromised) {
                            errorDiv.textContent = 'Potential security risk: Key compromise detected. Please refresh the page to generate a new key.';
                            sessionStorage.removeItem('aesKey');
                            sessionStorage.removeItem('aesIV');
                            sessionStorage.removeItem('aesKeyTimestamp');
                            sessionStorage.removeItem('hashedKey');
                        }
                    }
                }
            }

            setInterval(periodicKeyCheck, KEY_CHECK_INTERVAL);

            if (PREVENT_AUTOFILL) {
                urlInput.setAttribute("autocomplete", "off");
                urlInput.setAttribute("autocorrect", "off");
                urlInput.setAttribute("spellcheck", "false");
            }

            browseButton.addEventListener('click', async () => {
                let url = urlInput.value.trim();

                if (!url) {
                    errorDiv.textContent = 'Please enter a URL.';
                    return;
                }

                if (url.length > MAX_URL_LENGTH) {
                    errorDiv.textContent = `URL exceeds maximum length of ${MAX_URL_LENGTH} characters.`;
                    return;
                }

                try {
                  browseButton.disabled = true;
                  browseButton.classList.add('disabled');

                  if (!url.startsWith('http://') && !url.startsWith('https://')) {
                      url = 'https://' + url;
                      urlInput.value = url;
                  }

                    try {
                        new URL(url);
                    } catch (_) {
                        errorDiv.textContent = 'Please enter a valid URL.';
                        return;
                    }

                    const nonce = generateNonce(NONCE_LENGTH);
                    console.log("Request Nonce:", nonce);

                    let aesKeyHex = sessionStorage.getItem('aesKey');
                    let aesKey;

                    if (!aesKeyHex) {
                        aesKey = await generateAESKey();
                        const rawKey = await window.crypto.subtle.exportKey("raw", aesKey);
                        const keyArray = Array.from(new Uint8Array(rawKey));
                        aesKeyHex = keyArray.map(b => b.toString(16).padStart(2, '0')).join('');
                    } else {
                        const keyBytes = new Uint8Array(aesKeyHex.match(/[\da-f]{2}/gi).map(h => parseInt(h, 16)));
                        aesKey = await window.crypto.subtle.importKey(
                            "raw",
                            keyBytes,
                            { name: "AES-GCM", length: AES_KEY_LENGTH },
                            false,
                            ["encrypt", "decrypt"]
                        );
                    }

                    const { ciphertext, iv } = await encryptURL(url, aesKey);

                    const hashedKey = await hashKey(aesKeyHex);
                    console.log("Hashed Key:", hashedKey);

                    const isCompromised = await checkKeyCompromise(hashedKey);
                    if (isCompromised) {
                        errorDiv.textContent = 'Potential security risk: Key compromise detected.';
                        return;
                    }

                    sessionStorage.setItem('aesIV', iv);

                    sessionStorage.setItem('aesKey', aesKeyHex);
                    sessionStorage.setItem('aesKeyTimestamp', Date.now().toString());
                    sessionStorage.setItem('hashedKey',hashedKey);

                    const formData = new FormData();
                    formData.append('ciphertext', ciphertext);
                    formData.append('nonce', nonce);
                    formData.append('keyHash', hashedKey);

                    loadingDiv.style.display = 'block';
                    errorDiv.textContent = '';
                    proxyFrame.style.display = 'block';

                    proxyFrame.sandbox = 'allow-forms allow-scripts allow-same-origin allow-popups allow-downloads';
                    let cspValue = `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self';`;
                    if (ENABLE_CSP) {
                        proxyFrame.setAttribute('csp', cspValue);
                    }

                    fetch(PROXY_URL, {
                        method: 'POST',
                        body: formData,
                        redirect: 'manual'
                    })
                    .then(response => {
                        if (REDIRECT_STATUS_CODES.includes(response.status)) {
                            const redirectUrl = response.headers.get('Location');
                            console.log("Redirect detected:", redirectUrl);
                            if (ENCRYPT_REDIRECTS) {
                                return encryptAndProxy(redirectUrl);
                            } else {
                                proxyFrame.src = redirectUrl;
                                return;
                            }
                        }
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }
                        return response.text();
                    })
                    .then(html => {
                        proxyFrame.contentWindow.document.open();
                        proxyFrame.contentWindow.document.write(html);
                        proxyFrame.contentWindow.document.close();

                        if (PREFETCH_SUBRESOURCES) {
                            prefetchSubresources(html);
                        }

                        proxyFrame.contentWindow.postMessage({ type: 'proxyLoaded' }, ALLOWED_FRAME_ORIGIN);

                    })
                    .catch(error => {
                        console.error("Error loading proxy:", error);
                        errorDiv.textContent = 'Failed to load the page within the iframe.';
                    })
                    .finally(() => {
                        clearTimeout(timeoutId);
                        loadingDiv.style.display = 'none';
                    });

                    const timeoutId = setTimeout(() => {
                        if (loadingDiv.style.display === 'block') {
                            loadingDiv.style.display = 'none';
                            errorDiv.textContent = 'Request timed out. Please try again.';
                            proxyFrame.src = '';
                        }
                    }, LOAD_TIMEOUT);

                    function clearSensitiveData() {
                        sessionStorage.removeItem('aesKey');
                        sessionStorage.removeItem('aesIV');
                        sessionStorage.removeItem('aesKeyTimestamp');
                        sessionStorage.removeItem('hashedKey');
                    }

                    setTimeout(() => {
                        clearSensitiveData();
                    }, KEY_STORAGE_DURATION);

                } catch (e) {
                    handleErrors(e);
                } finally {
                    browseButton.disabled = false;
                    browseButton.classList.remove('disabled');
                    setTimeout(() => {
                        loadingDiv.style.display = 'none';
                    }, 500);
                }
            });

            function displayKeyExpiryWarning() {
                const storedTimestamp = sessionStorage.getItem('aesKeyTimestamp');
                if (storedTimestamp) {
                    const timestamp = parseInt(storedTimestamp, 10);
                    const timeLeft = KEY_STORAGE_DURATION - (Date.now() - timestamp);
                    if (timeLeft <= 60000) {
                        keyExpiryWarningDiv.style.display = 'block';
                    } else {
                        keyExpiryWarningDiv.style.display = 'none';
                    }
                } else {
                    keyExpiryWarningDiv.style.display = 'none';
                }
            }

            setInterval(() => {
                const storedTimestamp = sessionStorage.getItem('aesKeyTimestamp');
                if (storedTimestamp) {
                    const timestamp = parseInt(storedTimestamp, 10);
                    if (Date.now() - timestamp > KEY_STORAGE_DURATION) {
                        console.log("AES Key expired. Clearing from sessionStorage.");
                        sessionStorage.removeItem('aesKey');
                        sessionStorage.removeItem('aesIV');
                        sessionStorage.removeItem('aesKeyTimestamp');
                        sessionStorage.removeItem('hashedKey');
                         keyExpiryWarningDiv.style.display = 'none';
                    } else {
                         displayKeyExpiryWarning();
                    }
                }
            }, KEY_EXPIRY_CHECK_INTERVAL);

            displayKeyExpiryWarning();

            window.addEventListener('message', function(event) {
                if (event.origin === ALLOWED_FRAME_ORIGIN && event.data.type === 'proxyLoaded') {
                    console.log('Iframe proxy loaded successfully.');
                }
            });

            async function encryptAndProxy(redirectUrl) {
                try {
                  const nonce = generateNonce(NONCE_LENGTH);
                  console.log("Redirect Nonce:", nonce);

                  let aesKeyHex = sessionStorage.getItem('aesKey');
                  let aesKey;

                  if (!aesKeyHex) {
                      aesKey = await generateAESKey();
                      const rawKey = await window.crypto.subtle.exportKey("raw", aesKey);
                      const keyArray = Array.from(new Uint8Array(rawKey));
                      aesKeyHex = keyArray.map(b => b.toString(16).padStart(2, '0')).join('');
                  } else {
                      const keyBytes = new Uint8Array(aesKeyHex.match(/[\da-f]{2}/gi).map(h => parseInt(h, 16)));
                      aesKey = await window.crypto.subtle.importKey(
                          "raw",
                          keyBytes,
                          { name: "AES-GCM", length: AES_KEY_LENGTH },
                          false,
                          ["encrypt", "decrypt"]
                      );
                  }

                  const { ciphertext, iv } = await encryptURL(redirectUrl, aesKey);

                  const hashedKey = await hashKey(aesKeyHex);
                  console.log("Hashed Key:", hashedKey);

                   const isCompromised = await checkKeyCompromise(hashedKey);
                  if (isCompromised) {
                      errorDiv.textContent = 'Potential security risk: Key compromise detected.';
                      return;
                  }

                  sessionStorage.setItem('aesIV', iv);

                  sessionStorage.setItem('aesKey', aesKeyHex);
                  sessionStorage.setItem('aesKeyTimestamp', Date.now().toString());
                  sessionStorage.setItem('hashedKey',hashedKey);

                  const formData = new FormData();
                  formData.append('ciphertext', ciphertext);
                  formData.append('nonce', nonce);
                  formData.append('keyHash', hashedKey);

                  loadingDiv.style.display = 'block';
                  errorDiv.textContent = '';
                  proxyFrame.style.display = 'block';

                  proxyFrame.sandbox = 'allow-forms allow-scripts allow-same-origin allow-popups allow-downloads';
                    let cspValue = `default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; font-src 'self'; connect-src 'self';`;
                    if (ENABLE_CSP) {
                        proxyFrame.setAttribute('csp', cspValue);
                    }

                  return fetch(PROXY_URL, {
                      method: 'POST',
                      body: formData,
                  })
                  .then(response => {
                      if (!response.ok) {
                          throw new Error(`HTTP error! status: ${response.status}`);
                      }
                      return response.text();
                  })
                  .then(html => {
                      proxyFrame.contentWindow.document.open();
                      proxyFrame.contentWindow.document.write(html);
                      proxyFrame.contentWindow.document.close();

                      if (PREFETCH_SUBRESOURCES) {
                          prefetchSubresources(html);
                      }

                      proxyFrame.contentWindow.postMessage({ type: 'proxyLoaded' }, ALLOWED_FRAME_ORIGIN);
                  });
                } catch (error) {
                  console.error("Error handling redirect:", error);
                  errorDiv.textContent = 'Failed to load the redirect page.';
                } finally {
                    clearTimeout(timeoutId);
                    loadingDiv.style.display = 'none';
                }
            }

           async function prefetchSubresources(html) {
                const parser = new DOMParser();
                const doc = parser.parseFromString(html, 'text/html');
                const subresourceTypes = ['link[rel="stylesheet"]', 'script[src]', 'img[src]'];

                for (const selector of subresourceTypes) {
                    const elements = doc.querySelectorAll(selector);
                    for (const element of elements) {
                        let url;
                        if (element.tagName === 'LINK') {
                            url = element.href;
                        } else if (element.tagName === 'SCRIPT' || element.tagName === 'IMG') {
                            url = element.src;
                        }

                        if (url) {
                            const prefetchLink = document.createElement('link');
                            prefetchLink.rel = 'prefetch';
                            prefetchLink.href = url;

                            if (SUBRESOURCE_INTEGRITY && element.tagName === 'SCRIPT' && element.integrity) {
                                prefetchLink.integrity = element.integrity;
                                prefetchLink.crossOrigin = 'anonymous';
                            }

                            document.head.appendChild(prefetchLink);
                            console.log('Prefetching:', url);
                        }
                    }
                }
            }

            if (ENABLE_HSTS) {
                if (window.location.protocol === 'https:') {
                    const hstsHeader = `max-age=${HSTS_MAX_AGE}`;
                    const includeSubDomains = HSTS_INCLUDE_SUBDOMAINS ? '; includeSubDomains' : '';
                    const preload = '; preload';
                    const fullHstsHeader = hstsHeader + includeSubDomains + preload;
                    console.log("HSTS Header (Client-Side):", fullHstsHeader);

                    // The actual HSTS header should be set by the server.
                    // This client-side logging helps in debugging.
                } else {
                    console.warn("HSTS is enabled but not using HTTPS. HSTS will not be effective.");
                }
            }

            if (ENABLE_WEBGPU && navigator.gpu) {
                console.log("WebGPU is supported!");
            } else {
                console.log("WebGPU is not supported or disabled.");
            }
        });

        particlesJS.load('particles-js', 'particles-config.json', function() {
            console.log('callback - particles.js config loaded');
        });
    </script>
    <script src="particles.js"></script>
</body>
</html>